# CPAR算法
## 1.关联规则分类的步骤
#### 一般而言，关联规则分类包括以下步骤：

1. 挖掘数据，得到频繁项集。
2. 分析频繁项集，产生每个类的关联规则，它们满足置信度和支持度标准。
3. 组织规则，形成**基于规则的分类器**。

## 2.关联规则分类算法：
关联规则分类方法的**不同**：挖掘频繁项集所用的方法、如何将被分析的规则导出并用于分类。
### 2.1 CBA算法
**CBA**：Classification Based on Association
> ##### 2.1.1 寻找频繁项集
>  CBA使用迭代方法挖掘频繁项集，类似于Apriori算法。找出满足最小置信度和支持度阈值的规则的完全集后，然后分析，找出包含在分类器中的规则。
> ##### 2.1.2 构造分类器
> CBA使用一种启发式方法构造分类器，其中规则按照它们的置信度和支持度递减优先级排序。其中，有三条规则如下：
> 
> - 如果一组规则具有相同的前件，则选取具有最高置信度的规则代表该集合。
> - 在对新元组分类时，使用满足该元组的第一个规则对它进行分类。
> - 具有最低优先级，用来为不能被分类器中其他规则满足的新元组指定默认类。
> 
> 一般而言，实验表明CBA在大量数据集上比C4.5更准确。
### 2.2 CMAR算法
**CMAR**：Classificationbased on Multiple Association Rules
> ##### 2.2.1 寻找频繁项集
> CMAR采用**FP—Growth算法的变形**来发现满足最小支持度和最小置信度阈值的规则的完全集。
> 
> 同时，使用一种**加强的FP-树**，记录满足每个频繁项集的元组的类标号分布。这样，它可以把规则产生与频繁项集挖掘合并成一步。
> ##### 2.2.2 规则的发现与处理
> CMAR还使用**另一种树结构**来有效地存储和提取规则，并根据置信度、相关度和数据库覆盖率对规则剪枝。当规则插入该树时就触发规则剪枝策略。
> 
> **剪枝策略**：如果规则存在具有更高置信度的更泛化的版本，则可以剪去具有低置信度的更特殊化的规则。
> 
> 一个例子：给定两个规则R1和R2，如果R1的前件比R2更一般，并且conf（R1）>=conf（R2），则剪去R2。
> ##### 2.2.3 如果多个规则可用，我们使用哪一个？
> CMAR算法将所有的规则分组，每一组有着相同的类编号。
> 
> 当需要预测X时，CMAR使用**加权的卡方度量**，根据组中规则的统计相关性找出“最强的”规则组。然后把X的类标号指派为最强的组的类标号。（并不是将x对应到某一规则，二是一个规则组）
> 
> 实验表明，CMAR比CBA的平均准确率稍高。它的运行时间、可伸缩性和内存使用都更有效。

### 2.3 CPAR算法
**CPAR**：Classificationbased on Predictive Association Rules
> ##### 2.3.1 产生规则
> 基于一种称作FOIL的分类规则产生算法。
> 
> FOIL构造规则来区别**正元组**和**负元组**。对于多类问题，解决办法：one vs rest。
> 
> 每当产生一个规则时，就删除它满足（或覆盖）的正样本，直到数据集合中所有的正元组都被覆盖。这样，产生的规则更少，CPAR放宽了这一步，**允许被覆盖的元组留下并被考虑，但是降低它们的权重。**对每个类重复该过程。结果规则被合并在一起，形成分类器的规则集。
> ##### 2.3.2 如果多个规则可用，我们使用哪一个？
> 如果多个规则满足新元组X，则类似于CMAR，这些规则将按类分组。然而，CPAR根据**期望准确率**，使用每组中的最好的k个规则预测X的类标号。（可以**跨组**）
> 
> ##### 在大量数据集上，CPAR的准确率与CMAR接近。然而，由于CPAR产生的规则比CMAR少得多，对于大型训练数据集，CPAR有效得多。

## 3.参考文献：
1.https://blog.csdn.net/dq_dm/article/details/39519397